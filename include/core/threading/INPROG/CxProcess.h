#ifndef CX_CORE_THREADING_CXPROCESS_H
#define CX_CORE_THREADING_CXPROCESS_H
/**
 * @copyright Catlin Zilinksi, 2014.  All rights reserved.
 *
 * @file CxProcess.h: 
 * @brief Contains the definition for the ProcessRunner class.
 *
 * @author Catlin Zilinski
 * @date Nov 12, 2015
 */

#include "core/Cx.h"
#include "core/common/CxStrID.h"
#include "core/common/CxInvasiveStrongPtr.h"

namespace cat {

	class CxProcessRunner;

	/**
	 * @class CxProcess CxProcess.h "core/threading/CxProcess.h"
	 * @brief The Class that represents a runnable process.
	 *
	 * The CxProcess is different from a CxTask in that a CxProcess
	 * does not run to completion, when it calls the process
	 * method, it it runs for a specified number of steps, then returns
	 * to allow another process on the same process runner to run.
	 *
	 * @since Mar 4, 2014
	 * @version 2
	 * @author Catlin Zilinski
	 */

	class CxProcess {
	  public:
		/** @brief Create an unnamed process with an autogenerated PID. */
		CxProcess(CxI32 in_cost = 1, CxI32 in_priority = 1);

		/** @brief Create a named process with an autogenerated PID. */
		CxProcess(const CxChar *in_name, CxI32 in_cost = 1, CxI32 in_priority = 1);

		/** @brief Virtual destructor for sub classes */
		~CxProcess();

		/** @return The per-step cost modifier for the process. */
		CX_FORCE_INLINE CxI32 cost() const { return m_cost; }
		
		/** @return The exit status of the process. */
		CX_FORCE_INLINE ExitStatus exitStatus() const { return m_exitStatus; }

		/** @brief Set the status / exit status for a process that has failed. */
		void fail();

		/** @return True if the process has failed. */
		CX_FORCE_INLINE CxBool failed() const {
			return m_exitStatus == kFailed;
		}

		/**
		 * @brief Get the number of steps this process should run for.
		 * The number of steps depends on the priority and cost of the process,
		 * and the default number of steps the process runner passes in.
		 * @param in_steps The default number of steps a process should run for.
		 * @return The number of steps the process should run for (>= 1).
		 */
		CX_FORCE_INLINE CxI32 getRequestedRunTime(CxI32 in_steps) const {
			const CxI32 t = (in_steps * m_priority) / m_cost;
			return (t > 0) ? t : 1;
		}

		/** @return True if the process is running or paused */
		CX_FORCE_INLINE CxBool isActive() const {
			return (m_status == kRunning || m_status == kPaused);
		}

		/** @return True if the process has succeeded, failed or been terminated. */
		CX_FORCE_INLINE CxBool isDone() const {
			return (m_status == kDone);
		}

		/** 
		 * @brief Method to call after process has failed. 
		 * @param in_runner The CxProcessRunner that was running the process.
		 * @return True if the process should be removed now, or later.
		 */
		virtual CxBool onFailure(CxProcessRunner *in_runner);

		/** 
		 * @brief Method to call after process has been paused. 
		 * @param in_runner The CxProcessRunner that is running the process.
		 */
		virtual void onPause(CxProcessRunner *in_runner);

		/** 
		 * @brief Method to call after process has been resumed. 
		 * @param in_runner The CxProcessRunner that is running the process.
		 */
		virtual void onResume(CxProcessRunner *in_runner);

	   /** 
		 * @brief Method to call after process has been started. 
		 * @param in_runner The CxProcessRunner that will be running the process.
		 */
		virtual void onStart(CxProcessRunner *in_runner);

		/** 
		 * @brief Method to call after process has succeeded. 
		 * @param in_runner The CxProcessRunner that was running the process.
		 * @return True if the process should be removed now, or later.
		 */
		virtual CxBool onSuccess(CxProcessRunner *in_runner);

		/** 
		 * @brief Method to call after process has been terminated. 
		 * @param in_runner The CxProcessRunner that was running the process.
		 * @return True if the process should be removed now, or later.
		 */
		virtual CxBool onTermination(CxProcessRunner *in_runner);

		/** @return The process ID (PID). */
		CX_FORCE_INLINE CxU64 pid() const { return m_pid; }

		/** @return The priority of the process */
		CX_FORCE_INLINE CxI32 priority() const { return m_priority; }

		/** @brief Method to run the process for the specified number of steps. */
		virtual void process(CxI32 in_steps) = 0;

		/** @brief Set the per-step cost modifier for the process. */
		CX_FORCE_INLINE setCost(CxI32 in_cost) { m_const = in_cost; }

		/** @brief Set the priority of the process */
		CX_FORCE_INLINE setPriority(CxI32 in_priority) const { m_priority = in_priority; }

		/** @brief Set the current status of the process. */
		CX_FORCE_INLINE void setStatus(Status in_new) { m_status = in_new; }

		/** @return The current status of the process. */
		CX_FORCE_INLINE Status status() const { return m_status; }

		/** @return The string ID of the process */
		CX_FORCE_INLINE const CxStrID & strID() const { return m_id; }

		/** @return True if the process has succeeded */
		CX_FORCE_INLINE CxBool succeeded() const {
			return m_exitStatus == kSucceeded;
		}
		
		/** @brief Method to set the status and exit status for successful finishing. */
		void success();

		/** @brief Method to set the status and exit status for a terminated process. */
		void terminate();

		/** @return True if the process has been terminated. */
		CX_FORCE_INLINE CxBool terminated() const {
			return m_exitStatus == kTerminated;
		}

		CX_ISPTR_METHODS;

		/** @return The next autogenerated PID for a process */
		static CX_FORCE_INLINE CxU64 generatePID() { return ++s_autoPID; }

	  protected:
		CxU64 m_pid;
		CxStrID m_name;

		CxI32 m_priority;
		CxI32 m_cost;

	   CX_ISPTR_FIELDS;

		Status m_status;
		ExitStatus m_exitStatus;

	  private:
		static CxU64 s_autoPID;
	};

	typedef CxInvasiveStrongPtr<CxProcess> CxProcessPtr;
	
} // namespace

#endif // CX_CORE_THREADING_CXPROCESS_H
